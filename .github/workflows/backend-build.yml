# Production-Ready Backend Build
#
# PURPOSE: Build and test Rust backend with PostgreSQL database
# WHY: Real production setup with database integration testing
# WHEN: Runs on every push/PR to backend code

name: Production Backend Build

# When to run this workflow - only when called by backend-ci.yml
on:
  workflow_call:

jobs:
  build:
    name: Build Rust Backend with Database
    runs-on: ubuntu-latest


    # Environment variables for the build
    env:
      # Database connection for SQLx compile-time verification with Supabase
      DATABASE_URL: postgresql://postgres:${{ secrets.POSTGRES_PASSWORD }}@db.exibcfqpurfoztnejcts.supabase.co:5432/postgres
      # Individual components for debugging
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_HOST: db.exibcfqpurfoztnejcts.supabase.co
      POSTGRES_PORT: 5432
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres
      DATABASE_MAX_CONNECTIONS: 5
      # Rust build optimization
      CARGO_INCREMENTAL: 0
      # Ensure consistent builds
      RUSTFLAGS: "-C target-cpu=native"
      # Logging
      RUST_LOG: info

    steps:
      # Get the code
      - name: Checkout code
        uses: actions/checkout@v4

                        # Verify environment variables
      - name: Verify environment setup
        run: |
          echo "ğŸ”§ Verifying environment setup..."

          if [[ -n "$DATABASE_URL" ]]; then
            echo "âœ… DATABASE_URL is available at job level (${#DATABASE_URL} chars)"
            echo "âœ… DATABASE_URL starts with: $(echo "$DATABASE_URL" | cut -c1-25)..."
          else
            echo "âŒ DATABASE_URL is not available at job level!"
            exit 1
          fi

          if [[ -n "$POSTGRES_PASSWORD" ]]; then
            echo "âœ… POSTGRES_PASSWORD is available (length: ${#POSTGRES_PASSWORD})"
          else
            echo "âŒ POSTGRES_PASSWORD is not available!"
            exit 1
          fi

      # Show build environment
      - name: Show build environment
        run: |
          echo "ğŸ”§ Build Environment:"
          echo "RUSTFLAGS: $RUSTFLAGS"
          echo "Rust version: $(rustc --version)"
          echo "Cargo version: $(cargo --version)"
          echo "PostgreSQL version: $(psql --version)"

          # Verify DATABASE_URL
          if [[ -n "$DATABASE_URL" ]]; then
            echo "âœ… DATABASE_URL is properly set"
            # Simple length check instead of sed masking to avoid corruption
            echo "DATABASE_URL length: ${#DATABASE_URL} characters"
            echo "DATABASE_URL starts with: $(echo "$DATABASE_URL" | cut -c1-20)..."
          else
            echo "âŒ DATABASE_URL is not set!"
            exit 1
          fi

      # Install Rust
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      # Wait for PostgreSQL to be ready
      - name: Wait for PostgreSQL
        run: |
          echo "ğŸ”„ Waiting for PostgreSQL to be ready..."
          until pg_isready -h db.exibcfqpurfoztnejcts.supabase.co -p 5432; do
            echo "Waiting for Supabase PostgreSQL..."
            sleep 2
          done
          echo "âœ… Supabase PostgreSQL is ready!"

          # Test database connection
          echo "ğŸ” Testing database connection..."
          if [[ -n "${{ secrets.POSTGRES_PASSWORD }}" ]]; then
            echo "âœ… POSTGRES_PASSWORD secret is available"
            # Test connection (will fail if password is wrong)
            PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}" psql -h db.exibcfqpurfoztnejcts.supabase.co -U postgres -d postgres -c "SELECT 1;" && echo "âœ… Database connection successful" || echo "âŒ Database connection failed"
          else
            echo "âŒ POSTGRES_PASSWORD secret is not set!"
            exit 1
          fi

                  # Set up database schema
      - name: Set up database
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          cd moneywise-backend
          echo "ğŸ—„ï¸ Setting up database schema..."

          # Create the trigger function first
          psql -h db.exibcfqpurfoztnejcts.supabase.co -U postgres -d postgres -c "
          CREATE OR REPLACE FUNCTION public.update_updated_at_column()
          RETURNS TRIGGER AS \$\$
          BEGIN
              NEW.updated_at = CURRENT_TIMESTAMP;
              RETURN NEW;
          END;
          \$\$ language 'plpgsql';"

          # Run the migration
          psql -h db.exibcfqpurfoztnejcts.supabase.co -U postgres -d postgres -f migrations/20241201000000_initial_schema.sql

          echo "âœ… Database setup completed!"

      # Verify project structure
      - name: Verify project structure
        run: |
          cd moneywise-backend
          echo "ğŸ“ Project Structure:"
          echo "Cargo.toml exists: $([ -f "Cargo.toml" ] && echo "âœ…" || echo "âŒ")"
          echo "src/ directory exists: $([ -d "src" ] && echo "âœ…" || echo "âŒ")"
          echo "main.rs exists: $([ -f "src/main.rs" ] && echo "âœ…" || echo "âŒ")"
          echo "Dependencies in Cargo.toml:"
          grep -E "^\[dependencies\]|^[a-zA-Z]" Cargo.toml | head -10

      # Verify environment before build
      - name: Verify build environment
        run: |
          cd moneywise-backend
          echo "ğŸ” Verifying build environment..."

          # Check if DATABASE_URL is set and valid
          if [[ -z "$DATABASE_URL" ]]; then
            echo "âŒ ERROR: DATABASE_URL is not set!"
            echo "Available environment variables:"
            env | grep -E "(DATABASE|POSTGRES)" || echo "No database-related environment variables found"
            exit 1
          fi

          echo "âœ… DATABASE_URL is set (${#DATABASE_URL} chars): $(echo "$DATABASE_URL" | cut -c1-25)..."

          # Test SQLx can connect
          echo "ğŸ” Testing SQLx connection..."
          cargo check --quiet 2>&1 | head -20 || true

      # Build the project
      - name: Build project
        run: |
          cd moneywise-backend
          echo "ğŸš€ Starting build process..."
          echo "ğŸ“Š Build target: release"
          echo "ğŸ”§ DATABASE_URL length: ${#DATABASE_URL} characters"

          # Build with verbose output for better debugging
          cargo build --release --verbose

          echo "âœ… Build process completed!"

      # Test that it works
      - name: Test build
        run: |
          cd moneywise-backend
          # Check that the binary was created
          if [ -f "target/release/moneywise-backend" ]; then
            echo "âœ… Binary built successfully!"
            ls -la target/release/moneywise-backend
            echo "ğŸ“Š Binary size: $(du -h target/release/moneywise-backend | cut -f1)"

            # Show additional build info
            echo "ğŸ“ Build artifacts:"
            ls -la target/release/ | head -10

            # Test that the binary is executable
            echo "ğŸ”§ Testing binary execution:"
            ./target/release/moneywise-backend --help 2>/dev/null || echo "Binary runs (help not implemented)"

          else
            echo "âŒ Binary not found!"
            echo "ğŸ“ Contents of target/release/:"
            ls -la target/release/ || echo "target/release/ directory not found"
            echo "ğŸ“ Contents of target/:"
            ls -la target/ || echo "target/ directory not found"
            exit 1
          fi
