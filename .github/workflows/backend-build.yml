# Production-Ready Backend Build
#
# This file combines three separate workflows:
# 1. database-setup.yml - Database connection and verification
# 2. rust-setup.yml - Rust toolchain and project structure setup
# 3. build-and-test.yml - Building and testing the backend
#
# Flow:
# setup-db â†’ setup-rust â†’ build
# Each job must succeed before the next can start

name: Production Backend Build

on:
  workflow_call:

jobs:
  # ==========================================
  # In backend-database-setup.yml
  # Purpose: Ensures Supabase connection works
  # ==========================================
  setup-db:
    name: Setup Database Connection
    runs-on: ubuntu-latest
    env:
      # Supabase Configuration
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}

      # Database Configuration (derived from Supabase)
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
      POSTGRES_PORT: 5432
      POSTGRES_USER: postgres
      POSTGRES_DB: postgres

      # Application Configuration
      HOST: 127.0.0.1
      PORT: 3000
      RUST_LOG: info
    outputs:
      # This output is used by the build job to determine if it should run
      db_ready: ${{ steps.check_db.outputs.ready }}
    steps:
      - name: Verify dependencies
        run: |
          # Verify that curl is available (it should be pre-installed on ubuntu-latest)
          echo "âœ… Curl version:"
          curl --version

          echo "âœ… System information:"
          echo "OS: $(lsb_release -d | cut -f2)"
          echo "Architecture: $(uname -m)"

      - name: Check Supabase API connection
        id: check_db
        run: |
          # Test Supabase API connectivity instead of direct database connection
          # This is more reliable as it doesn't require direct port 5432 access
          echo "ðŸ”„ Testing Supabase API connectivity..."

          # Debug environment variables (without exposing secrets)
          echo "Debug: SUPABASE_URL is set: $([ -n "$SUPABASE_URL" ] && echo "âœ…" || echo "âŒ")"
          echo "Debug: SUPABASE_ANON_KEY is set: $([ -n "$SUPABASE_ANON_KEY" ] && echo "âœ…" || echo "âŒ")"
          echo "Debug: URL endpoint: ${SUPABASE_URL}/rest/v1/"

          max_retries=10
          retry_count=0

          until [ $retry_count -ge $max_retries ]; do
            # Test with explicit error handling and verbose output on failure
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${SUPABASE_ANON_KEY}" \
              -H "apikey: ${SUPABASE_ANON_KEY}" \
              "${SUPABASE_URL}/rest/v1/" 2>&1)

            if [ "$response" = "200" ]; then
              echo "âœ… Supabase API is accessible (HTTP $response)"
              echo "ready=true" >> $GITHUB_OUTPUT
              exit 0
            elif [ "$response" = "401" ]; then
              echo "âœ… Supabase API is accessible but authentication failed (HTTP $response) - this is expected for anonymous access"
              echo "ready=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "â³ Supabase API not ready (HTTP $response), retrying..."
              # On last retry, show more detailed error information
              if [ $retry_count -eq $((max_retries - 1)) ]; then
                echo "ðŸ” Debugging last attempt with verbose output:"
                curl -v -H "Authorization: Bearer ${SUPABASE_ANON_KEY}" \
                     -H "apikey: ${SUPABASE_ANON_KEY}" \
                     "${SUPABASE_URL}/rest/v1/" 2>&1 | head -20
              fi
              retry_count=$((retry_count + 1))
              sleep 3
            fi
          done

          echo "âŒ Supabase API not accessible after $max_retries attempts"
          echo "ready=false" >> $GITHUB_OUTPUT
          exit 1

  # ==========================================
  # In backend-rust-setup.yml
  # Purpose: Sets up Rust environment
  # ==========================================
  setup-rust:
    name: Setup Rust Environment
    # Only starts after database setup is complete
    needs: setup-db
    runs-on: ubuntu-latest
    outputs:
      # This output is used by the build job
      rust_ready: ${{ steps.verify_setup.outputs.ready }}
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      - name: Verify project structure
        id: verify_setup
        run: |
          # Simplified version of rust-setup.yml verification
          cd moneywise-backend
          if [ -f "Cargo.toml" ] && [ -d "src" ]; then
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # ==========================================
  # In backend-build-test.yml
  # Purpose: Actual build and test process
  # ==========================================
  build:
    name: Build and Test Backend
    # Only starts after both setup jobs are complete
    needs: [setup-db, setup-rust]
    runs-on: ubuntu-latest
    # Only runs if both setup jobs reported success
    if: ${{ needs.setup-db.outputs.db_ready == 'true' && needs.setup-rust.outputs.rust_ready == 'true' }}
    steps:
      - uses: actions/checkout@v4
      - name: Build project
        run: |
          # Simplified version of build-and-test.yml
          # but maintains core build functionality
          cd moneywise-backend
          cargo build --release --verbose